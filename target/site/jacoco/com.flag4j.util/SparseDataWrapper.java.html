<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SparseDataWrapper.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flag4j</a> &gt; <a href="index.source.html" class="el_package">com.flag4j.util</a> &gt; <span class="el_source">SparseDataWrapper.java</span></div><h1>SparseDataWrapper.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright (c) 2023 Jacob Watters
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.flag4j.util;

import com.flag4j.operations.dense.real.RealDenseTranspose;

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

/**
 * &lt;p&gt;A wrapper to wrap the entries and indices from a sparse tensor, vector, or matrix. This wrapper can then be used
 * to sort the indices, along with data values, in lexicographical order.&lt;/p&gt;
 *
 * &lt;p&gt;Specifically, if a sparse tensor has shape (10, 15, 5, 2) and the following indices and non-zero values,
 * &lt;pre&gt;
 *      - Indices: {{4, 1, 2, 0}, {4, 0, 1, 2},
 *                  {1, 2, 3, 0}, {2, 3, 5, 1},
 *                  {9, 10, 4, 1}, {1, 2, 1, 1}}
 *      - Values: {1.1, 2.2, 3.3, 4.4, 5.5, 6.6}
 * &lt;/pre&gt;
 * then the sorted indices and non-zero values will be,
 * &lt;pre&gt;
 *      - Indices: {{1, 2, 1, 1}, {1, 2, 3, 0},
 *                  {2, 3, 5, 1}, {4, 0, 1, 2},
 *                  {4, 1, 2, 0}, {9, 10, 4, 1}}
 *      - Values: {6.6, 3.3, 4.4, 2.2, 1.1, 5.5}
 * &lt;/pre&gt;
 * &lt;/p&gt;
 *
 * @param &lt;T&gt; Type of the individual entry within the sparse tensor.
 */
public final class SparseDataWrapper&lt;T&gt; {

    /**
     * Non-zero values of the sparse tensor to wrap.
     */
    private final List&lt;T&gt; values;
    /**
     * Stores wrapped indices. Each list is a single index for the {@code values} data. If the tensor is of rank {@code N}, then
     * each List in {@code keys} will have {@code N} entries. If there are {@code M} non-zero entries in the
     * sparse tensor, then there will be {@code M} lists in the array.
     */
    private final List&lt;Integer&gt;[] keys;


    /**
     * Wraps the data, and it's associated indices, of a sparse tensor.
     * @param values Non-zero values of the sparse tensor.
     * @param indices Indices of non-zero values in the sparse tensor.
     * @param transpose Indicates if a transpose should be applied to the indices array.
     */
<span class="fc" id="L75">    private SparseDataWrapper(T[] values, int[][] indices, boolean transpose) {</span>
<span class="fc" id="L76">        this.values = Arrays.asList(values);</span>
<span class="pc bpc" id="L77" title="1 of 2 branches missed.">        this.keys = transpose ? new List[indices[0].length] : new List[indices.length];</span>

<span class="pc bpc" id="L79" title="1 of 2 branches missed.">        int[][] indicesT = transpose ? RealDenseTranspose.blockedIntMatrix(indices) : indices;</span>

<span class="fc bfc" id="L81" title="All 2 branches covered.">        for(int i=0; i&lt;indicesT.length; i++) {</span>
<span class="pc bpc" id="L82" title="1 of 2 branches missed.">            if(values.length != indicesT[i].length) {</span>
<span class="nc" id="L83">                throw new IllegalArgumentException(&quot;All lists must have the same length.&quot;);</span>
            }

<span class="fc" id="L86">            this.keys[i] = IntStream.of(indicesT[i]).boxed().collect(Collectors.toList());</span>
        }
<span class="fc" id="L88">    }</span>


    /**
     * Factory method which wraps data in an instance of {@link SparseDataWrapper} and returns that instance.
     * @param values Non-zero values of the sparse tensor.
     * @param indices Indices of non-zero values in the sparse tensor.
     * @param &lt;T&gt; Type of the individual entry within {@code values}.
     * @return A new instance of {@link SparseDataWrapper} which wraps the specified {@code values} and {@code indices}.
     */
    public static &lt;T extends Number&gt; SparseDataWrapper&lt;T&gt; wrap(T[] values, int[][] indices) {
<span class="nc" id="L99">        return new SparseDataWrapper&lt;&gt;(values, indices, true);</span>
    }


    /**
     * Factory method which wraps data in an instance of {@link SparseDataWrapper} and returns that instance.
     * @param values Non-zero values of the sparse tensor.
     * @param indices Indices of non-zero values in the sparse tensor.
     * @param &lt;T&gt; Type of the individual entry within {@code values}.
     * @return A new instance of {@link SparseDataWrapper} which wraps the specified {@code values} and {@code indices}.
     */
    public static &lt;T extends Number&gt; SparseDataWrapper&lt;T&gt; wrap(T[] values, int[] indices) {
<span class="nc" id="L111">        return new SparseDataWrapper&lt;&gt;(values, new int[][]{indices}, false);</span>
    }


    /**
     * Factory method which wraps data in an instance of {@link SparseDataWrapper} and returns that instance.
     * @param values Non-zero values of the sparse tensor.
     * @param indices Indices of non-zero values in the sparse tensor.
     * @return A new instance of {@link SparseDataWrapper} which wraps the specified {@code values} and {@code indices}.
     */
    public static SparseDataWrapper&lt;Double&gt; wrap(double[] values, int[][] indices) {
        // Wrap the primitive array.
<span class="nc" id="L123">        return new SparseDataWrapper&lt;&gt;(Arrays.stream(values).boxed().toArray(Double[]::new), indices, true);</span>
    }


    /**
     * Factory method which wraps data in an instance of {@link SparseDataWrapper} and returns that instance.
     * @param values Non-zero values of the sparse tensor.
     * @param indices Indices of non-zero values in the sparse tensor.
     * @return A new instance of {@link SparseDataWrapper} which wraps the specified {@code values} and {@code indices}.
     */
    public static SparseDataWrapper&lt;Double&gt; wrap(double[] values, int[] indices) {
        // Wrap the primitive array.
<span class="fc" id="L135">        return new SparseDataWrapper&lt;&gt;(Arrays.stream(values).boxed().toArray(Double[]::new), new int[][]{indices}, false);</span>
    }


    /**
     * Sorts the wrapped indices in lexicographical order while maintaining the order of the non-zero values so that
     * their order matches the order of the indices.
     * @return A reference to this sparse data wrapper.
     */
    public SparseDataWrapper&lt;T&gt; sparseSort() {
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">        if(values.size() &gt; 2) {</span>
            // Only need to sort list with more than 1 entry.
<span class="fc" id="L147">            sparseSortHelper(0, 0, values.size());</span>
        }

<span class="fc" id="L150">        return this;</span>
    }


    /**
     * Sorts the specified key list over a specified range. During sorting, when swaps are made in the key list, the
     * same indices are swapped in all other lists within the wrapper. This is done recursively top down.
     * @param keyIdx Index of key list within {@link #keys}.
     * @param start Staring index of range to sort the key list over (inclusive).
     * @param stop Stopping index of range to sort the key list over (exclusive).
     */
    private void sparseSortHelper(int keyIdx, int start, int stop) {
<span class="pc bpc" id="L162" title="3 of 6 branches missed.">        if(start&gt;=stop-1 || keyIdx&gt;=keys.length || keyIdx&lt;0) {</span>
<span class="nc" id="L163">            return; // No sorting to do.</span>
        }

<span class="fc" id="L166">        List&lt;Integer&gt; key = keys[keyIdx].subList(start, stop);</span>

        // Create a List of indices.
<span class="fc" id="L169">        List&lt;Integer&gt; indices = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for(int i=0; i&lt;key.size(); i++) {</span>
<span class="fc" id="L171">            indices.add(i);</span>
        }

        // Sort the indices list based on the key list.
<span class="fc" id="L175">        indices.sort(Comparator.comparingInt(key::get));</span>

<span class="fc" id="L177">        Map&lt;Integer, Integer&gt; swapMap = new HashMap&lt;&gt;(indices.size());</span>
<span class="fc" id="L178">        List&lt;Integer&gt; swapFrom = new ArrayList&lt;&gt;(indices.size()),</span>
<span class="fc" id="L179">                swapTo = new ArrayList&lt;&gt;(indices.size());</span>

        // Create map to facilitate reordering list to match sorted indices.
<span class="fc bfc" id="L182" title="All 2 branches covered.">        for(int i=0; i&lt;key.size(); i++) {</span>
<span class="fc" id="L183">            int k = indices.get(i);</span>

<span class="fc bfc" id="L185" title="All 4 branches covered.">            while(i != k &amp;&amp; swapMap.containsKey(k)) {</span>
<span class="fc" id="L186">                k = swapMap.get(k);</span>
            }

<span class="fc" id="L189">            swapFrom.add(i);</span>
<span class="fc" id="L190">            swapTo.add(k);</span>
<span class="fc" id="L191">            swapMap.put(i, k);</span>
        }

        // Use map to reorder values sub-list.
<span class="fc" id="L195">        List&lt;T&gt; valuesSubList = values.subList(start, stop);</span>
<span class="fc bfc" id="L196" title="All 2 branches covered.">        for(int i=0; i&lt;key.size(); i++) {</span>
<span class="fc" id="L197">            Collections.swap(valuesSubList, swapFrom.get(i), swapTo.get(i));</span>
        }

        // Use map to reorder each key sub-list.
<span class="fc bfc" id="L201" title="All 2 branches covered.">        for(List&lt;Integer&gt; list : keys) {</span>
<span class="fc" id="L202">            List&lt;Integer&gt; subList = list.subList(start, stop);</span>

<span class="fc bfc" id="L204" title="All 2 branches covered.">            for (int i = 0; i &lt; key.size(); i++) {</span>
<span class="fc" id="L205">                Collections.swap(subList, swapFrom.get(i), swapTo.get(i));</span>
            }
        }

        // Find ranges which have the same value in the sorted key list.
<span class="fc" id="L210">        int startCounter = 0;</span>
<span class="fc" id="L211">        int endCounter = 1;</span>
<span class="fc bfc" id="L212" title="All 2 branches covered.">        while(endCounter&lt;key.size()) {</span>
<span class="pc bpc" id="L213" title="1 of 2 branches missed.">            if(!key.get(startCounter).equals(key.get(endCounter))) {</span>
<span class="pc bpc" id="L214" title="1 of 2 branches missed.">                if(endCounter-startCounter &gt; 1) {</span>
                    // Sort the range of the next key list.
<span class="nc" id="L216">                    sparseSortHelper(keyIdx+1, startCounter+start, endCounter+start);</span>
                }

<span class="fc" id="L219">                startCounter=endCounter;</span>
            }

<span class="fc" id="L222">            endCounter++;</span>
        }

        // Check for final range of same values.
<span class="pc bpc" id="L226" title="1 of 2 branches missed.">        if(startCounter!=endCounter-1) {</span>
            // Sort the range of the next key list.
<span class="nc" id="L228">            sparseSortHelper(keyIdx+1, startCounter+start, endCounter+start);</span>
        }
<span class="fc" id="L230">    }</span>


    /**
     * Unwraps sparse data values and indices.
     * @param values Storage for unwrapped values. Must have the same length as that passed to the constructor. Modified.
     * @param indices Storage for unwrapped indices. Must have the same shape as that passed to the constructor. Modified.
     */
    public void unwrap(T[] values, int[][] indices) {
        // Copy over data values.
<span class="nc bnc" id="L240" title="All 2 branches missed.">        for(int i=0; i&lt;this.values.size(); i++) {</span>
<span class="nc" id="L241">            values[i] = this.values.get(i);</span>
        }

        // Copy over indices (must be transposed).
<span class="nc bnc" id="L245" title="All 2 branches missed.">        for(int i=0; i&lt;indices.length; i++) {</span>
<span class="nc bnc" id="L246" title="All 2 branches missed.">            for(int j=0; j&lt;indices[0].length; j++) {</span>
<span class="nc" id="L247">                indices[i][j] = this.keys[j].get(i);</span>
            }
        }
<span class="nc" id="L250">    }</span>


    /**
     * Unwraps sparse data values and indices.
     * @param values Storage for unwrapped values. Must have the same length as that passed to the constructor. Modified.
     * @param indices Storage for unwrapped indices. Must have the same shape as that passed to the constructor. Modified.
     */
    public void unwrap(T[] values, int[] indices) {
        // Copy over data values.
<span class="nc bnc" id="L260" title="All 2 branches missed.">        for(int i=0; i&lt;this.values.size(); i++) {</span>
<span class="nc" id="L261">            values[i] = this.values.get(i);</span>
        }

        // Copy over indices (must be transposed).
<span class="nc bnc" id="L265" title="All 2 branches missed.">        for(int i=0; i&lt;indices.length; i++) {</span>
<span class="nc" id="L266">            indices[i] = this.keys[0].get(i);</span>
        }
<span class="nc" id="L268">    }</span>


    /**
     * Unwraps sparse data values and indices.
     * @param values Storage for unwrapped values. Must have the same length as that passed to the constructor. Modified.
     * @param indices Storage for unwrapped indices. Must have the same shape as that passed to the constructor. Modified.
     */
    public void unwrap(double[] values, int[][] indices) {
        // Copy over data values.
<span class="nc bnc" id="L278" title="All 2 branches missed.">        for(int i=0; i&lt;this.values.size(); i++) {</span>
<span class="nc" id="L279">            values[i] = (double) this.values.get(i);</span>
        }

        // Copy over indices (must be transposed).
<span class="nc bnc" id="L283" title="All 2 branches missed.">        for(int i=0; i&lt;indices.length; i++) {</span>
<span class="nc bnc" id="L284" title="All 2 branches missed.">            for(int j=0; j&lt;indices[0].length; j++) {</span>
<span class="nc" id="L285">                indices[i][j] = this.keys[j].get(i);</span>
            }
        }
<span class="nc" id="L288">    }</span>


    /**
     * Unwraps sparse data values and indices.
     * @param values Storage for unwrapped values. Must have the same length as that passed to the constructor. Modified.
     * @param indices Storage for unwrapped indices. Must have the same shape as that passed to the constructor. Modified.
     */
    public void unwrap(double[] values, int[] indices) {
        // Copy over data values.
<span class="fc bfc" id="L298" title="All 2 branches covered.">        for(int i=0; i&lt;this.values.size(); i++) {</span>
<span class="fc" id="L299">            values[i] = (double) this.values.get(i);</span>
        }

        // Copy over indices (must be transposed).
<span class="fc bfc" id="L303" title="All 2 branches covered.">        for(int i=0; i&lt;values.length; i++) {</span>
<span class="fc" id="L304">            indices[i] = this.keys[0].get(i);</span>
        }
<span class="fc" id="L306">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>