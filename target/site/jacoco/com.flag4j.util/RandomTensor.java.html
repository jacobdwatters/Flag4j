<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RandomTensor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flag4j</a> &gt; <a href="index.source.html" class="el_package">com.flag4j.util</a> &gt; <span class="el_source">RandomTensor.java</span></div><h1>RandomTensor.java</h1><pre class="source lang-java linenums">/*
 * MIT License
 *
 * Copyright (c) 2022-2023 Jacob Watters
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the &quot;Software&quot;), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

package com.flag4j.util;

import com.flag4j.*;
import com.flag4j.complex_numbers.CNumber;
import com.flag4j.linalg.Decompose;
import com.flag4j.linalg.decompositions.ComplexQRDecomposition;
import com.flag4j.linalg.decompositions.RealQRDecomposition;

/**
 * An instance of this class is used for generating streams of pseudorandom tensors, matrices, and vectors.
 */
public class RandomTensor {
    /**
     * Complex pseudorandom number generator.
     */
    private final RandomCNumber complexRng;

    /**
     * Constructs a new pseudorandom tensor generator with a seed which is unlikely to be the same as other
     * from any other invocation of this constructor.
     */
<span class="nc" id="L46">    public RandomTensor() {</span>
<span class="nc" id="L47">        complexRng = new RandomCNumber();</span>
<span class="nc" id="L48">    }</span>

    /**
     * Constructs a pseudorandom tensor generator with a specified seed. Use this constructor for reproducible results.
     * @param seed Seed of the pseudorandom tensor generator.
     */
<span class="nc" id="L54">    public RandomTensor(long seed) {</span>
<span class="nc" id="L55">        complexRng = new RandomCNumber(seed);</span>
<span class="nc" id="L56">    }</span>


    /**
     * Generates a tensor filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     * @param shape Shape of the tensor.
     * @return A tensor filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     */
    public Tensor randomTensor(Shape shape) {
<span class="nc" id="L65">        return new Tensor(shape, genUniformRealArray(shape.totalEntries().intValueExact()));</span>
    }


    /**
     * Generates a tensor filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @param shape Shape of the tensor.
     * @param min Minimum value for the uniform distribution.
     * @param max Maximum value for the uniform distribution.
     * @return A tensor filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code max} is less than {@code min}.
     */
    public Tensor randomTensor(Shape shape, double min, double max) {
<span class="nc" id="L78">        return new Tensor(shape, genUniformRealArray(</span>
<span class="nc" id="L79">                shape.totalEntries().intValueExact(),</span>
                min,
                max)
        );
    }


    /**
     * Generates a tensor filled with pseudorandom values sampled from a normal distribution with
     * mean of 0.0 and standard deviation of 1.0.
     * @param shape Shape of the tensor.
     * @return A tensor filled with pseudorandom values sampled from a normal distribution with
     * mean of 0.0 and standard deviation of 1.0.
     */
    public Tensor randnTensor(Shape shape) {
<span class="nc" id="L94">        return new Tensor(shape, genNormalRealArray(shape.totalEntries().intValueExact()));</span>
    }


    /**
     * Generates a tensor filled with pseudorandom values sampled from a normal distribution with
     * specified mean and standard deviation.
     * @param shape Shape of the tensor.
     * @param mean Mean of the normal distribution to sample from.
     * @param std Standard deviation of normal distribution to sample from.
     * @return A tensor filled with pseudorandom values sampled from a normal distribution with
     * specified mean and standard deviation.
     * @throws IllegalArgumentException If standard deviation is negative.
     */
    public Tensor randnTensor(Shape shape, double mean, double std) {
<span class="nc" id="L109">        return new Tensor(shape, genNormalRealArray(</span>
<span class="nc" id="L110">                shape.totalEntries().intValueExact(),</span>
                mean,
                std)
        );
    }


    /**
     * Generates a tensor filled with pseudorandom complex values with magnitudes
     * uniformly distributed in {@code [0, 1)}.
     * @param shape Shape of the tensor.
     * @return A tensor filled with pseudorandom complex values with magnitudes
     * uniformly distributed in {@code [0, 1)}.
     */
    public CTensor randomCTensor(Shape shape) {
<span class="nc" id="L125">        return new CTensor(shape, genUniformComplexArray(shape.totalEntries().intValueExact()));</span>
    }


    /**
     * Generates a tensor filled with pseudorandom values with magnitudes uniformly distributed in {@code [min, max)}.
     * @param shape Shape of the tensor.
     * @param min Minimum value for the uniform distribution from which to sample magnitude.
     * @param max Maximum value for the uniform distribution from which to sample magnitude.
     * @return A tensor filled with pseudorandom values with magnitudes uniformly distributed in {@code [min, max)}
     * @throws IllegalArgumentException If {@code min} is negative or if {@code max} is less than {@code min}.
     */
    public CTensor randomCTensor(Shape shape, double min, double max) {
<span class="nc" id="L138">        return new CTensor(shape, genUniformComplexArray(</span>
<span class="nc" id="L139">                shape.totalEntries().intValueExact(),</span>
                min,
                max)
        );
    }


    /**
     * Generates a tensor filled with pseudorandom values sampled from a normal distribution with
     * mean of 0.0 and standard deviation of 1.0.
     * @param shape Shape of the tensor.
     * @return A tensor filled with pseudorandom values sampled from a normal distribution with
     * mean of 0.0 and standard deviation of 1.0.
     */
    public CTensor randnCTensor(Shape shape) {
<span class="nc" id="L154">        return new CTensor(shape, genNormalComplexArray(shape.totalEntries().intValueExact()));</span>
    }


    /**
     * Generates a tensor filled with pseudorandom values sampled from a normal distribution with
     * specified mean and standard deviation.
     * @param shape Shape of the tensor.
     * @param mean Mean of the normal distribution to sample from.
     * @param std Standard deviation of normal distribution to sample from.
     * @return A tensor filled with pseudorandom values sampled from a normal distribution with
     * specified mean and standard deviation.
     * @throws IllegalArgumentException If standard deviation is negative.
     */
    public CTensor randnCTensor(Shape shape, double mean, double std) {
<span class="nc" id="L169">        return new CTensor(shape, genNormalComplexArray(</span>
<span class="nc" id="L170">                shape.totalEntries().intValueExact(),</span>
                mean,
                std)
        );
    }


    /**
     * Generates a vector filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     */
    public Vector randomVector(int size) {
<span class="nc" id="L183">        return new Vector(genUniformRealArray(size));</span>
    }



    /**
     * Generates a vector filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code max} is less than {@code min}.
     */
    public Vector randomVector(int size, double min, double max) {
<span class="nc" id="L195">        return new Vector(genUniformRealArray(size, min, max));</span>
    }


    /**
     * Generates a vector filled with pseudorandom values sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     */
    public Vector randnVector(int size) {
<span class="nc" id="L207">        return new Vector(genNormalRealArray(size));</span>
    }


    /**
     * Generates a vector filled with pseudorandom values sampled from a normal distribution with specified mean
     * and standard deviation.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values sampled from a normal distribution with specified mean
     * and standard deviation.
     * @throws IllegalArgumentException If the standard deviation is negative.
     */
    public Vector randnVector(int size, double mean, double std) {
<span class="nc" id="L220">        return new Vector(genNormalRealArray(size));</span>
    }



    /**
     * Generates a vector filled with pseudorandom complex values with magnitudes uniformly distributed in {@code [0, 1)}.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom complex values with magnitudes uniformly distributed in {@code [0, 1)}.
     */
    public CVector randomCVector(int size) {
<span class="nc" id="L231">        return new CVector(genUniformComplexArray(size));</span>
    }



    /**
     * Generates a vector filled with pseudorandom values with magnitudes uniformly distributed in {@code [min, max)}.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values with magnitudes uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code min} is negative or if {@code max} is less than {@code min}.
     */
    public CVector randomCVector(int size, double min, double max) {
<span class="nc" id="L243">        return new CVector(genUniformComplexArray(size, min, max));</span>
    }


    /**
     * Generates a vector filled with pseudorandom values with magnitudes sampled from a normal distribution with a
     * mean of 0.0 and a standard deviation of 1.0.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values with magnitudes sampled from a normal distribution with a
     * mean of 0.0 and a standard deviation of 1.0.
     */
    public CVector randnCVector(int size) {
<span class="nc" id="L255">        return new CVector(genNormalComplexArray(size));</span>
    }


    /**
     * Generates a vector filled with pseudorandom values with magnitudes sampled from a normal distribution with specified mean
     * and standard deviation.
     * @param size Size of the vector to generate.
     * @return A vector filled with pseudorandom values with magnitudes sampled from a normal distribution with specified mean
     *      * and standard deviation.
     * @throws IllegalArgumentException If the standard deviation is negative.
     */
    public CVector randnCVector(int size, double mean, double std) {
<span class="nc" id="L268">        return new CVector(genNormalComplexArray(size, mean, std));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     * @param rows Number of rows in the resulting matrix.
     * @param cols Number of columns in the resulting matrix.
     * @return A matrix filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     */
    public Matrix randomMatrix(int rows, int cols) {
<span class="nc" id="L279">        return new Matrix(rows, cols, genUniformRealArray(rows*cols));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     * @param shape Shape of the resulting matrix. Must be of rank 2.
     * @return A matrix filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     * @throws IllegalArgumentException If the {@code shape} is not of rank 2.
     */
    public Matrix randomMatrix(Shape shape) {
<span class="nc" id="L290">        return randomMatrix(shape.get(0), shape.get(1));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @param rows Number of rows in the resulting matrix.
     * @param cols Number of columns in the resulting matrix.
     * @param min Minimum value of uniform distribution to sample from (inclusive).
     * @param max Maximum value of uniform distribution to sample from (exclusive).
     * @return A matrix filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code max} is less than {@code min}.
     */
    public Matrix randomMatrix(int rows, int cols, double min, double max) {
<span class="nc" id="L304">        return new Matrix(rows, cols, genUniformRealArray(rows*cols, min, max));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @param shape Shape of the resulting matrix. Must be of rank 2.
     * @param min Minimum value of uniform distribution to sample from (inclusive).
     * @param max Maximum value of uniform distribution to sample from (exclusive).
     * @return A matrix filled with pseudorandom values uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code max} is less than {@code min}.
     * @throws IllegalArgumentException If {@code shape} is not of rank 2.
     */
    public Matrix randomMatrix(Shape shape, double min, double max) {
<span class="nc" id="L318">        return randomMatrix(shape.get(0), shape.get(1), min, max);</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     * @param rows The number of rows in the resulting matrix.
     * @param cols The number of columns in the resulting matrix.
     * @return A matrix filled with pseudorandom values sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     */
    public Matrix randnMatrix(int rows, int cols) {
<span class="nc" id="L331">        return new Matrix(rows, cols, genNormalRealArray(rows*cols));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     * @param shape Shape of the resulting matrix.
     * @return A matrix filled with pseudorandom values sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     */
    public Matrix randnMatrix(Shape shape) {
<span class="nc" id="L343">        return randnMatrix(shape.get(0), shape.get(1));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values sampled from a normal distribution with a specified mean
     * and standard deviation.
     * @param rows The number of rows in the resulting matrix.
     * @param cols The number of columns in the resulting matrix.
     * @param mean Mean of the normal distribution from which values are sampled.
     * @param std Standard deviation of the normal distribution from which values are sampled.
     * @return A matrix filled with pseudorandom values sampled from a normal distribution with a specified mean
     * and standard deviation.
     * @throws IllegalArgumentException If the standard deviation is negative.
     */
    public Matrix randnMatrix(int rows, int cols, double mean, double std) {
<span class="nc" id="L359">        return new Matrix(rows, cols, genNormalRealArray(rows*cols, mean, std));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values sampled from a normal distribution with a specified mean
     * and standard deviation.
     * @param shape Shape of the resulting matrix.
     * @param mean Mean of the normal distribution from which values are sampled.
     * @param std Standard deviation of the normal distribution from which values are sampled.
     * @return A matrix filled with pseudorandom values sampled from a normal distribution with a specified mean
     * and standard deviation.
     * @throws IllegalArgumentException If the standard deviation is negative.
     */
    public Matrix randnMatrix(Shape shape, double mean, double std) {
<span class="nc" id="L374">        return randnMatrix(shape.get(0), shape.get(1), mean, std);</span>
    }


    /**
     * Generates a symmetric matrix filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     * @param size Number of rows and columns in the resulting matrix (the result will be a square matrix).
     * @return A symmetric matrix filled with pseudorandom values uniformly distributed in {@code [0, 1)}.
     */
    public Matrix getRandomSymmetricMatrix(int size) {
<span class="nc" id="L384">        Matrix randMat = new Matrix(size);</span>

<span class="nc bnc" id="L386" title="All 2 branches missed.">        for(int i=0; i&lt;size; i++) {</span>
<span class="nc bnc" id="L387" title="All 2 branches missed.">            for(int j=0; j&lt;i; j++) {</span>
<span class="nc" id="L388">                randMat.entries[i*size+j] = complexRng.rng.nextDouble();</span>
<span class="nc" id="L389">                randMat.entries[j*size+i] = randMat.entries[i*size+j];</span>
            }

<span class="nc" id="L392">            randMat.entries[i*(size+1)] = complexRng.rng.nextDouble(); // Diagonal entry</span>
        }

<span class="nc" id="L395">        return randMat;</span>
    }


    /**
     * Gets a pseudorandom orthogonal matrix. From an implementation point of view, a pseudorandom matrix is generated
     * as if by {@link #randomMatrix(int, int) getRandomMatrix(size, size)}. Then, a {@link Decompose#qr(Matrix) QR}
     * decomposition is computed on this pseudorandom matrix and the {@code Q} matrix from this decomposition is returned.
     * @param size Size of the orthogonal matrix (i.e. the number rows and columns for the square matrix).
     * @return A pseudorandom orthogonal matrix.
     */
    public Matrix randomOrthogonalMatrix(int size) {
<span class="nc" id="L407">        Matrix randMat = new Matrix(size, size, genUniformRealArray(size));</span>
<span class="nc" id="L408">        return new RealQRDecomposition().decompose(randMat).getQ();</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes uniformly
     * distributed in {@code [0, 1)}.
     * @param rows Number of rows in the resulting matrix.
     * @param cols Number of columns in the resulting matrix.
     * @return A matrix filled with pseudorandom complex values with magnitudes uniformly
     * distributed in {@code [0, 1)}.
     */
    public CMatrix randomCMatrix(int rows, int cols) {
<span class="nc" id="L421">        return new CMatrix(rows, cols, genUniformComplexArray(rows*cols));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes uniformly
     * distributed in {@code [0, 1)}.
     * @param shape Shape of the resulting matrix. Must be of rank 2.
     * @return A matrix filled with pseudorandom complex values with magnitudes uniformly
     * distributed in {@code [0, 1)}.
     * @throws IllegalArgumentException If the {@code shape} is not of rank 2.
     */
    public CMatrix randomCMatrix(Shape shape) {
<span class="nc" id="L434">        return randomCMatrix(shape.get(0), shape.get(1));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes
     * uniformly distributed in {@code [min, max)}.
     * @param rows Number of rows in the resulting matrix.
     * @param cols Number of columns in the resulting matrix.
     * @param min Minimum value of uniform distribution to sample from (inclusive).
     * @param max Maximum value of uniform distribution to sample from (exclusive).
     * @return A matrix filled with pseudorandom complex values with magnitudes
     * uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code max} is less than {@code min}.
     */
    public CMatrix randomCMatrix(int rows, int cols, double min, double max) {
<span class="nc" id="L450">        return new CMatrix(rows, cols, genUniformComplexArray(rows*cols, min, max));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes
     * uniformly distributed in {@code [min, max)}.
     * @param shape Shape of the resulting matrix. Must be of rank 2.
     * @param min Minimum value of uniform distribution to sample from (inclusive).
     * @param max Maximum value of uniform distribution to sample from (exclusive).
     * @return A matrix filled with pseudorandom complex values with magnitudes
     * uniformly distributed in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code max} is less than {@code min}.
     * @throws IllegalArgumentException If {@code shape} is not of rank 2.
     */
    public CMatrix randomCMatrix(Shape shape, double min, double max) {
<span class="nc" id="L466">        return randomCMatrix(shape.get(0), shape.get(1), min, max);</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     * @param rows The number of rows in the resulting matrix.
     * @param cols The number of columns in the resulting matrix.
     * @return A matrix filled with pseudorandom complex values with magnitudes sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     */
    public CMatrix randnCMatrix(int rows, int cols) {
<span class="nc" id="L479">        return new CMatrix(rows, cols, genNormalComplexArray(rows*cols));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     * @param shape Shape of the resulting matrix.
     * @return A matrix filled with pseudorandom complex values with magnitudes sampled from a normal distribution with a mean of 0.0 and
     * a standard deviation of 1.0.
     */
    public CMatrix randnCMatrix(Shape shape) {
<span class="nc" id="L491">        return randnCMatrix(shape.get(0), shape.get(1));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom complex values with magnitudes sampled from a normal
     * distribution with a specified mean and standard deviation.
     * @param rows The number of rows in the resulting matrix.
     * @param cols The number of columns in the resulting matrix.
     * @param mean Mean of the normal distribution from which values are sampled.
     * @param std Standard deviation of the normal distribution from which values are sampled.
     * @return A matrix filled with pseudorandom complex values with magnitudes sampled from a normal
     * distribution with a specified mean and standard deviation.
     * @throws IllegalArgumentException If the standard deviation is negative.
     */
    public CMatrix randnCMatrix(int rows, int cols, double mean, double std) {
<span class="nc" id="L507">        return new CMatrix(rows, cols, genNormalComplexArray(rows*cols, mean, std));</span>
    }


    /**
     * Generates a matrix filled with pseudorandom values sampled from a normal distribution with a specified mean
     * and standard deviation.
     * @param shape Shape of the resulting matrix.
     * @param mean Mean of the normal distribution from which values are sampled.
     * @param std Standard deviation of the normal distribution from which values are sampled.
     * @return A matrix filled with pseudorandom values sampled from a normal distribution with a specified mean
     * and standard deviation.
     * @throws IllegalArgumentException If the standard deviation is negative.
     */
    public CMatrix randnCMatrix(Shape shape, double mean, double std) {
<span class="nc" id="L522">        return randnCMatrix(shape.get(0), shape.get(1), mean, std);</span>
    }


    /**
     * Gets a pseudorandom unitary matrix. From an implementation point of view, a pseudorandom complex matrix is generated
     * as if by {@link #randomCMatrix(int, int) getRandomMatrix(size, size)}. Then, a {@link Decompose#qr(CMatrix) QR}
     * decomposition is computed on this pseudorandom matrix and the {@code Q} matrix from this decomposition is returned.
     * @param size Size of the unitary matrix (i.e. the number rows and columns for the square matrix).
     * @return A pseudorandom unitary matrix.
     */
    public CMatrix randomUnitaryMatrix(int size) {
<span class="nc" id="L534">        CMatrix randMat = new CMatrix(size, size, genUniformComplexArray(size));</span>
<span class="nc" id="L535">        return new ComplexQRDecomposition().decompose(randMat).getQ();</span>
    }


    /**
     * Generates an array of doubles filled with uniformly distributed pseudorandom values in {@code [0.0, 1.0)}.
     * To generate uniformly distributed values in a specified range see {@link #genUniformRealArray(int, double, double)}.
     * @param length Length of pseudorandom array to generate.
     * @return An array of doubles with specified length filled with uniformly distributed values in {@code [0.0, 1.0)}.
     */
    private double[] genUniformRealArray(int length) {
<span class="nc" id="L546">        double[] values = new double[length];</span>

<span class="nc bnc" id="L548" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L549">            values[i] = complexRng.rng.nextDouble();</span>
        }

<span class="nc" id="L552">        return values;</span>
    }


    /**
     * Generates an array of doubles filled with uniformly distributed pseudorandom values in {@code [min, max)}.
     * @param length Length of pseudorandom array to generate.
     * @param min Lower bound of uniform range (inclusive).
     * @param max Upper bound of uniform range (Exclusive).
     * @return An array of doubles with specified length filled with uniformly distributed values in {@code [min, max)}.
     */
    private double[] genUniformRealArray(int length, double min, double max) {
<span class="nc" id="L564">        double[] values = new double[length];</span>

<span class="nc bnc" id="L566" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L567">            values[i] = complexRng.rng.nextDouble()*(max - min) + min;</span>
        }

<span class="nc" id="L570">        return values;</span>
    }


    /**
     * Generates an array of integers filled with uniformly distributed pseudorandom values in {@code [0, 1)}.
     * To generate uniformly distributed values in a specified range see {@link #genUniformRealIntArray(int, int, int)}.
     * @param length Length of pseudorandom array to generate.
     * @return An array of integers with specified length filled with uniformly distributed values in {@code [0, 1)}.
     */
    private double[] genUniformRealIntArray(int length) {
<span class="nc" id="L581">        double[] values = new double[length];</span>

<span class="nc bnc" id="L583" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L584">            values[i] = complexRng.rng.nextInt();</span>
        }

<span class="nc" id="L587">        return values;</span>
    }


    /**
     * Generates an array of integers filled with uniformly distributed pseudorandom values in {@code [min, max)}.
     * @param length Length of pseudorandom array to generate.
     * @param min Lower bound of uniform range (inclusive).
     * @param max Upper bound of uniform range (Exclusive).
     * @return An array of integers with specified length filled with uniformly distributed values in {@code [min, max)}.
     */
    private double[] genUniformRealIntArray(int length, int min, int max) {
<span class="nc" id="L599">        double[] values = new double[length];</span>

<span class="nc bnc" id="L601" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L602">            values[i] = complexRng.rng.nextInt()*((double) (max - min)) + min;</span>
        }

<span class="nc" id="L605">        return values;</span>
    }


    /**
     * Generates an array of doubles filled with normally pseudorandom values with a mean of 0 and standard deviation
     * of 1.
     * @param length Length of pseudorandom array to generate.
     * @return An array of doubles with specified length filled with normally pseudorandom values with a mean of 0 and
     * standard deviation of 1.
     */
    private double[] genNormalRealArray(int length) {
<span class="nc" id="L617">        double[] values = new double[length];</span>

<span class="nc bnc" id="L619" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L620">            values[i] = complexRng.rng.nextGaussian();</span>
        }

<span class="nc" id="L623">        return values;</span>
    }


    /**
     * Generates an array of doubles filled with normally distributed pseudorandom values with a specified mean and standard deviation.
     * @param length Length of pseudorandom array to generate.
     * @param mean Mean of normal distribution.
     * @param std Standard deviation of normal distribution.
     * @return An array of doubles with specified length filled with normally pseudorandom values specified mean and
     * standard deviation.
     * @throws IllegalArgumentException If standard deviation is negative.
     */
    private double[] genNormalRealArray(int length, double mean, double std) {
<span class="nc" id="L637">        double[] values = new double[length];</span>

<span class="nc bnc" id="L639" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L640">            values[i] = complexRng.rng.nextGaussian()*mean + std;</span>
        }

<span class="nc" id="L643">        return values;</span>
    }


    /**
     * Generates an array of {@link CNumber complex numbers} with pseudorandom uniformly distributed magnitudes
     * in {@code [0.0, 1.0)}.
     * @param length Length of the pseudorandom array to generate.
     * @return An array of {@link CNumber complex numbers} with pseudorandom uniformly distributed magnitudes
     * in {@code [0.0, 1.0)}.
     */
    private CNumber[] genUniformComplexArray(int length) {
<span class="nc" id="L655">        CNumber[] values = new CNumber[length];</span>

<span class="nc bnc" id="L657" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L658">            values[i] = complexRng.random();</span>
        }

<span class="nc" id="L661">        return values;</span>
    }


    /**
     * Generates an array of pseudorandom {@link CNumber complex numbers} with uniformly distributed magnitudes
     * in {@code [min, max)}.
     * @param length Length of the pseudorandom array to generate.
     * @param min Minimum value of uniform distribution from which the magnitudes are sampled (inclusive).
     * @param max Maximum value of uniform distribution from which the magnitudes are sampled (exclusive).
     * @return An array of {@link CNumber complex numbers} with pseudorandom {@link CNumber complex numbers} with
     * uniformly distributed magnitudes in {@code [min, max)}.
     * @throws IllegalArgumentException If {@code min} is negative or if {@code max} is less than {@code min}.
     */
    private CNumber[] genUniformComplexArray(int length, double min, double max) {
<span class="nc" id="L676">        CNumber[] values = new CNumber[length];</span>

<span class="nc bnc" id="L678" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L679">            values[i] = complexRng.random(min, max);</span>
        }

<span class="nc" id="L682">        return values;</span>
    }


    /**
     * Generates an array of {@link CNumber complex numbers} with pseudorandom normally distributed magnitudes
     * with a mean of 0.0 and a magnitude of 1.0.
     * @param length Length of the pseudorandom array to generate.
     * @return An array of {@link CNumber complex numbers} with pseudorandom normally distributed magnitudes
     * with a mean of 0.0 and a magnitude of 1.0.
     */
    private CNumber[] genNormalComplexArray(int length) {
<span class="nc" id="L694">        CNumber[] values = new CNumber[length];</span>

<span class="nc bnc" id="L696" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L697">            values[i] = complexRng.randn();</span>
        }

<span class="nc" id="L700">        return values;</span>
    }


    /**
     * Generates an array of {@link CNumber complex numbers} with pseudorandom normally distributed magnitudes
     * with specified mean and standard deviation.
     * @param length Length of the pseudorandom array to generate.
     * @param mean Mean of the normal distribution from which to sample magnitudes.
     * @param std Standard deviation of the normal distribution from which to sample magnitudes.
     * @return An array of {@link CNumber complex numbers} with pseudorandom normally distributed magnitudes
     * with specified mean and standard deviation.
     * @throws IllegalArgumentException If standard deviation is negative.
     */
    private CNumber[] genNormalComplexArray(int length, double mean, double std) {
<span class="nc" id="L715">        CNumber[] values = new CNumber[length];</span>

<span class="nc bnc" id="L717" title="All 2 branches missed.">        for(int i=0; i&lt;length; i++) {</span>
<span class="nc" id="L718">            values[i] = complexRng.randn(mean, std);</span>
        }

<span class="nc" id="L721">        return values;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>