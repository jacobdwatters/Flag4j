<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>CNumber.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Flag4j</a> &gt; <a href="index.source.html" class="el_package">com.flag4j.complex_numbers</a> &gt; <span class="el_source">CNumber.java</span></div><h1>CNumber.java</h1><pre class="source lang-java linenums">package com.flag4j.complex_numbers;

import com.flag4j.util.ErrorMessages;

import java.math.BigDecimal;
import java.math.RoundingMode;

/**
 * A complex number stored in rectangular form.
 */
public class CNumber extends Number {
    // TODO: Constants should be private and accessed through method which returns a clone
    // Several constants are provided for convenience.
    /**
     * The complex number with zero imaginary and real parts.
     */
<span class="fc" id="L17">    public final static CNumber ZERO = new CNumber();</span>
    /**
     * The complex number with zero imaginary part and one real part.
     */
<span class="fc" id="L21">    public final static CNumber ONE = new CNumber(1);</span>
    /**
     * The complex number with zero imaginary part and two real part.
     */
<span class="fc" id="L25">    public final static CNumber TWO = new CNumber(2);</span>
    /**
     * The complex number with zero imaginary part and negative one real part.
     */
<span class="fc" id="L29">    public final static CNumber NEGATIVE_ONE = new CNumber(1);</span>
    /**
     * The real double value closer to pi than any other.
     */
<span class="fc" id="L33">    public final static CNumber PI = new CNumber(Math.PI);</span>
    /**
     * The real double value closer to the mathematical constant e than any other.
     */
<span class="fc" id="L37">    public final static CNumber E = new CNumber(Math.E);</span>
    /**
     * The double value closer than any other to the square root of 2
     */
<span class="fc" id="L41">    public final static CNumber ROOT_TWO = new CNumber(Math.sqrt(2));</span>
    /**
     * The double value closer than any other to the square root of 3
     */
<span class="fc" id="L45">    public final static CNumber ROOT_THREE = new CNumber(Math.sqrt(3));</span>
    /**
     * The imaginary unit i.
     */
<span class="fc" id="L49">    public final static CNumber IMAGINARY_UNIT = new CNumber(0, 1);</span>
    /**
     * The additive inverse of the imaginary unit, -i.
     */
<span class="fc" id="L53">    public final static CNumber INV_IMAGINARY_UNIT = new CNumber(0, -1);</span>
    /**
     * The maximum real double value 1.7976931348623157E308.
     */
<span class="fc" id="L57">    public final static CNumber MAX_REAL = new CNumber(Double.MAX_VALUE);</span>
    /**
     * The minimum real double value 4.9E-324
     */
<span class="fc" id="L61">    public final static CNumber MIN_REAL = new CNumber(Double.MIN_VALUE);</span>
    /**
     * The smallest possible real normal double 2.2250738585072014E-308.
     */
<span class="fc" id="L65">    public final static CNumber MIN_REAL_NORMAL = new CNumber(Double.MIN_NORMAL);</span>
    /**
     * Complex number with real part equal to {@link Double#POSITIVE_INFINITY}.
     */
<span class="fc" id="L69">    public final static CNumber POSITIVE_INFINITY = new CNumber(Double.POSITIVE_INFINITY);</span>
    /**
     * Complex number with real part equal to {@link Double#NEGATIVE_INFINITY}.
     */
<span class="fc" id="L73">    public final static CNumber NEGATIVE_INFINITY = new CNumber(Double.NEGATIVE_INFINITY);</span>
    /**
     * Complex number with real and imaginary parts equal to {@link Double#NaN}.
     */
<span class="fc" id="L77">    public final static CNumber NaN = new CNumber(Double.NaN, Double.NaN);</span>

    /**
     * Real component of the complex number.
     */
    public double re;
    /**
     * Imaginary component of the complex number.
     */
    public double im;


    /**
     * Constructs a complex number with value and magnitude 0.
     */
<span class="fc" id="L92">    public CNumber() {</span>
<span class="fc" id="L93">        re = 0;</span>
<span class="fc" id="L94">        im = 0;</span>
<span class="fc" id="L95">    }</span>


    /**
     * Constructs a complex number with specified real component and zero imaginary component.
     * @param re Real component of complex number.
     */
<span class="fc" id="L102">    public CNumber(double re) {</span>
<span class="fc" id="L103">        this.re = re;</span>
<span class="fc" id="L104">        this.im = 0;</span>
<span class="fc" id="L105">    }</span>


    /**
     * Constructs a complex number with specified complex and real components.
     * @param re Real component of complex number.
     * @param im Imaginary component of complex number.
     */
<span class="fc" id="L113">    public CNumber(double re, double im) {</span>
<span class="fc" id="L114">        this.re = re;</span>
<span class="fc" id="L115">        this.im = im;</span>
<span class="fc" id="L116">    }</span>


    /**
     * Creates a new complex number which is the copy of the specified complex number.
     * @param num The complex number to copy.
     */
<span class="fc" id="L123">    public CNumber(CNumber num) {</span>
<span class="fc" id="L124">        this.re = num.re;</span>
<span class="fc" id="L125">        this.im = num.im;</span>
<span class="fc" id="L126">    }</span>


    /**
     * Constructs a complex number from a string of the form &quot;a +/- bi&quot; where and b are real values and either may be
     * omitted. i.e. &quot;a&quot;, &quot;bi&quot;, &quot;a +/- i&quot;, and &quot;i&quot; are all also valid.
     * @param num The string representation of a complex number.
     */
<span class="fc" id="L134">    public CNumber(String num) {</span>
<span class="fc" id="L135">        CNumber complexNum = CNumberParser.parseNumber(num);</span>
<span class="fc" id="L136">        this.re = complexNum.re;</span>
<span class="fc" id="L137">        this.im = complexNum.im;</span>
<span class="fc" id="L138">    }</span>


    /**
     * Creates a copy of this complex number. Same as {@link #clone()}.
     * @return A complex number with real and complex components equivalent to this complex number.
     */
    public CNumber copy() {
<span class="nc" id="L146">        return new CNumber(this);</span>
    }


    /**
     * Creates a copy of this complex number. Same as {@link #copy()}.
     * @return A complex number with real and complex components equivalent to this complex number.
     */
    @Override
    public CNumber clone() {
<span class="fc" id="L156">        return new CNumber(this);</span>
    }


    /**
     * Checks if two complex numbers are equal. That is, if both numbers have equivalent real and complex parts.
     * @param b The object to compare.
     * @return True if b is a complex number and is equivalent to this complex number in both the real and
     * imaginary components. False, otherwise.
     */
    @Override
    public boolean equals(Object b) {
<span class="fc" id="L168">        boolean result = false;</span>

<span class="fc bfc" id="L170" title="All 2 branches covered.">        if(b instanceof CNumber) {</span>
<span class="fc" id="L171">            CNumber bCopy = (CNumber) b;</span>

<span class="fc bfc" id="L173" title="All 4 branches covered.">            if(this.re==bCopy.re &amp;&amp; this.im==bCopy.im) {</span>
<span class="fc" id="L174">                result = true;</span>
            }
<span class="fc bfc" id="L176" title="All 2 branches covered.">        } else if(b instanceof Double) {</span>
<span class="fc" id="L177">            Double bCopy = (Double) b;</span>

<span class="pc bpc" id="L179" title="1 of 4 branches missed.">            if(this.re==bCopy &amp;&amp; this.im==0) {</span>
<span class="fc" id="L180">                result = true;</span>
            }
<span class="fc bfc" id="L182" title="All 2 branches covered.">        } else if(b instanceof Integer) {</span>
<span class="fc" id="L183">            Integer bCopy = (Integer) b;</span>

<span class="pc bpc" id="L185" title="1 of 4 branches missed.">            if(this.re==bCopy &amp;&amp; this.im==0) {</span>
<span class="fc" id="L186">                result = true;</span>
            }
        }

<span class="fc" id="L190">        return result;</span>
    }


    /**
     * Checks if a complex number is equal to some double value. That is, if the real component of this complex number
     * is zero and the real component is equivalent to the double parameter.
     * @param b The double to compare.
     * @return True if b is a complex number and is equivalent to this complex number in both the real and
     * imaginary components. False, otherwise.
     */
    public boolean equals(double b) {
<span class="pc bpc" id="L202" title="1 of 4 branches missed.">        boolean result = this.im==0 &amp;&amp; this.re==b;</span>
<span class="fc" id="L203">        return result;</span>
    }


    /**
     * Generates the hashcode for this CNumber.
     * @return An integer hash for this CNumber.
     */
    @Override
    public int hashCode() {
<span class="fc" id="L213">        final int hashPrime1 = 7;</span>
<span class="fc" id="L214">        final int hashPrime2 = 31;</span>

<span class="fc" id="L216">        int hash = hashPrime2*hashPrime1 + Double.hashCode(this.re);</span>
<span class="fc" id="L217">        hash = hashPrime2*hash + Double.hashCode(this.im);</span>
<span class="fc" id="L218">        return hash;</span>
    }


    /**
     * Gets the value of the specified number as an {@code int}. This will be calculated only with the real component of
     * this {@link CNumber}.
     *
     * @return the numeric value represented by this object after conversion
     * to type {@code int}.
     */
    @Override
    public int intValue() {
<span class="fc" id="L231">        return (int) re;</span>
    }


    /**
     * Gets the value of the specified number as a {@code long}. This will be calculated only with the real component of
     * this {@link CNumber}.
     *
     * @return the numeric value represented by this object after conversion
     * to type {@code long}.
     */
    @Override
    public long longValue() {
<span class="fc" id="L244">        return (long) re;</span>
    }


    /**
     * Gets the value of the specified number as a {@code float}. This will be calculated only with the real component of
     * this {@link CNumber}.
     *
     * @return the numeric value represented by this object after conversion
     * to type {@code float}.
     */
    @Override
    public float floatValue() {
<span class="fc" id="L257">        return (float) re;</span>
    }


    /**
     * Gets the value of the specified number as a {@code double}. This will be calculated only with the real component of
     * this {@link CNumber}.
     *
     * @return the numeric value represented by this object after conversion
     * to type {@code double}.
     */
    @Override
    public double doubleValue() {
<span class="fc" id="L270">        return re;</span>
    }


    /**
     * Gets the double value of the imaginary component of this complex number.
     * @return imaginary part of given Number as double
     */
    public double doubleImaginaryValue() {
<span class="fc" id="L279">        return im;</span>
    }


    /**
     * Note: This method may result in loss of accuracy
     *
     * @return imaginary part of given Number as float
     */
    public float floatImaginaryValue() {
<span class="fc" id="L289">        return (float) im;</span>
    }

    /**
     * Note: This method may result in loss of accuracy
     *
     * @return imaginary part of given Number as int
     */
    public int intImaginaryValue() {
<span class="fc" id="L298">        return (int) im;</span>
    }


    /**
     * Note: This method may result in loss of accuracy
     *
     * @return imaginary part of given Number as long
     */
    public long longImaginaryValue() {
<span class="fc" id="L308">        return (long) im;</span>
    }


    /**
     * Adds two complex numbers.
     * @param b The number to add to this complex number.
     * @return The result of adding this complex number with b.
     */
    public CNumber add(CNumber b) {
<span class="fc" id="L318">        return new CNumber(this.re + b.re, this.im + b.im);</span>
    }


    /**
     * Adds a double to a complex number.
     * @param b The double value to add to this complex number.
     * @return The result of adding b to this complex number.
     */
    public CNumber add(double b) {
<span class="fc" id="L328">        return new CNumber(this.re + b, this.im);</span>
    }


    /**
     * Subtracting two complex numbers.
     * @param b The number to subtract from complex number.
     * @return The result of subtracting b from this complex number.
     */
    public CNumber sub(CNumber b) {
<span class="fc" id="L338">        return new CNumber(this.re - b.re, this.im - b.im);</span>
    }


    /**
     * subtracts a double from a complex number.
     * @param b The double value to subtract from this complex number.
     * @return The result of subtracting b from this complex number.
     */
    public CNumber sub(double b) {
<span class="fc" id="L348">        return new CNumber(this.re - b, this.im);</span>
    }


    /**
     * Sums an array of complex numbers.
     * @param numbers Numbers to sum.
     * @return The sum of all values in numbers.
     */
    public static CNumber sum(CNumber... numbers) {
<span class="fc" id="L358">        double re = 0;</span>
<span class="fc" id="L359">        double im = 0;</span>

<span class="fc bfc" id="L361" title="All 2 branches covered.">        for(CNumber num : numbers) {</span>
<span class="fc" id="L362">               re += num.re;</span>
<span class="fc" id="L363">               im += num.im;</span>
        }

<span class="fc" id="L366">        return new CNumber(re, im);</span>
    }


    /**
     * Computes the multiplication of two complex numbers.
     *
     * @param b Second complex number in the product.
     * @return Product of this complex number with b.
     */
    public CNumber mult(CNumber b) {
<span class="fc" id="L377">        return new CNumber(</span>
                this.re*b.re - this.im*b.im,
                this.re*b.im + this.im*b.re
        );
    }


    /**
     * Computes the multiplication of a complex number and a double.
     *
     * @param b Second complex number in the product.
     * @return Product of this complex number with b.
     */
    public CNumber mult(double b) {
<span class="fc" id="L391">        return new CNumber(this.re*b, this.im*b);</span>
    }


    /**
     * Computes the division of two complex numbers.
     * @param b The divisor for the complex division.
     * @return The quotient of this complex number with b. If b is equivalent to {@link CNumber#ZERO} then
     *  {@link CNumber#NaN} is returned.
     */
    public CNumber div(CNumber b) {
        CNumber quotient;

<span class="pc bpc" id="L404" title="1 of 4 branches missed.">        if (this.equals(ZERO) &amp;&amp; !b.equals(ZERO)) {</span>
<span class="fc" id="L405">            quotient = new CNumber();</span>
        }
<span class="fc bfc" id="L407" title="All 4 branches covered.">        else if(b.isReal() &amp;&amp; !b.equals(ZERO)) {</span>
<span class="fc" id="L408">            quotient = new CNumber(this.re/b.re, this.im/b.re);</span>
        }
        else {
<span class="fc" id="L411">            double divisor = b.re*b.re + b.im*b.im;</span>

<span class="fc" id="L413">            quotient = new CNumber(</span>
                    (this.re*b.re + this.im*b.im) / divisor,
                    (this.im*b.re - this.re*b.im) / divisor);
        }

<span class="fc" id="L418">        return quotient;</span>
    }


    /**
     * Computes the division of a complex numbers with a double value.
     * @param b The divisor for the complex division.
     * @return The quotient of this complex number with b. If b is zero then
     *  {@link CNumber#NaN} is returned.
     */
    public CNumber div(double b) {
        CNumber quotient;

<span class="pc bpc" id="L431" title="1 of 4 branches missed.">        if (this.equals(ZERO) &amp;&amp; b != 0) {</span>
<span class="fc" id="L432">            quotient = new CNumber();</span>
        }
        else {
<span class="fc" id="L435">            quotient = new CNumber(this.re/b, this.im/b);</span>
        }

<span class="fc" id="L438">        return quotient;</span>
    }


    /**
     * Computes the absolute value / magnitude of a complex number. &lt;br&gt;
     * Note: This method is the same as {@link #mag()}.
     * If the magnitude is desired to be a double then see {@link #magAsDouble()}.
     * @return The absolute value/magnitude of this complex number.
     */
    public CNumber abs() {
<span class="fc" id="L449">        return new CNumber(magAsDouble());</span>
    }


    /**
     * Computes the magnitude value of a complex number. &lt;br&gt;
     * Note: This method is the same as {@link #abs()}. &lt;br&gt;
     * If the magnitude is desired to be a double then see {@link #magAsDouble()}.
     * @return The absolute value/magnitude of this complex number.
     */
    public CNumber mag() {
<span class="fc" id="L460">        return new CNumber(magAsDouble());</span>
    }


    /**
     * Computes the magnitude value of a complex number as a double. &lt;br&gt;
     * If the magnitude is desired to be a {@link CNumber} then see {@link #mag()}.
     * @return The absolute value/magnitude of this complex number as a double.
     */
    public double magAsDouble() {
<span class="fc" id="L470">        double mag = Math.sqrt(this.re*this.re + this.im*this.im);</span>
<span class="fc" id="L471">        return mag;</span>
    }


    /**
     * Computes the additive inverse of this complex number.
     * @return The additive inverse of this complex number.
     */
    public CNumber addInv() {
<span class="fc" id="L480">        return new CNumber(-this.re, -this.im);</span>
    }


    /**
     * Computes the multiplicative inverse of this complex number.
     * @return The additive inverse of this complex number.
     */
    public CNumber multInv() {
<span class="fc" id="L489">        return ONE.div(this);</span>
    }


    /**
     * Computes the complex conjugate of this complex number.
     * @return The complex conjugate of this complex number.
     */
    public CNumber conj() {
<span class="fc" id="L498">        return new CNumber(this.re, -this.im);</span>
    }


    /**
     * Compute a raised to the power of b. This method wraps {@link Math#pow(double, double)}
     * and returns a {@link CNumber}.
     * @param a The base.
     * @param b The exponent.
     * @return a raised to the power of b.
     */
    public static CNumber pow(double a, double b) {
<span class="fc" id="L510">        return new CNumber(Math.pow(a, b));</span>
    }


    /**
     * Compute a raised to the power of b.
     * and returns a {@link CNumber}.
     * @param a The base.
     * @param b The exponent.
     * @return a to the power of b.
     */
    public static CNumber pow(double a, CNumber b) {
        CNumber result;

<span class="fc bfc" id="L524" title="All 2 branches covered.">        if(b.isReal()) {</span>
<span class="fc" id="L525">            result = CNumber.pow(a, b.re);</span>
        } else {
            // Apply a change of base
<span class="fc" id="L528">            double logA = Math.log(a);</span>
<span class="fc" id="L529">            CNumber power = new CNumber(logA * b.re, logA * b.im);</span>
<span class="fc" id="L530">            result = exp(power);</span>
        }

<span class="fc" id="L533">        return result;</span>
    }


    /**
     * Compute a raised to the power of b.
     * and returns a {@link CNumber}.
     * @param a The base.
     * @param b The exponent.
     * @return a to the power of b.
     */
    public static CNumber pow(CNumber a, CNumber b) {
        CNumber result;

<span class="fc bfc" id="L547" title="All 2 branches covered.">        if(a.isReal()) {</span>
<span class="fc bfc" id="L548" title="All 2 branches covered.">            if(b.isReal()) {</span>
<span class="fc" id="L549">                result = CNumber.pow(a.re, b.re);</span>
            } else {
<span class="fc" id="L551">                result = CNumber.pow(a.re, b);</span>
            }
        } else {
<span class="fc" id="L554">            result = exp(b.mult(ln(a)));</span>
        }

<span class="fc" id="L557">        return result;</span>
    }


    /**
     * Computes the exponential function with the given input. This method simply wraps the {@link Math#exp(double)}
     * method and returns a {@link CNumber}.
     * @param exponent Input to the exponential function.
     * @return The output of the exponential function.
     */
    public static CNumber exp(double exponent) {
<span class="fc" id="L568">        double re = Math.exp(exponent);</span>
<span class="fc" id="L569">        return new CNumber(re);</span>
    }


    /**
     * Computes the exponential function with the given input.
     * @param exponent Input to the exponential function.
     * @return The output of the exponential function.
     */
    public static CNumber exp(CNumber exponent) {
<span class="fc" id="L579">        double expRe = Math.exp(exponent.re);</span>
<span class="fc" id="L580">        double re = expRe*Math.cos(exponent.im);</span>
<span class="fc" id="L581">        double im = expRe*Math.sin(exponent.im);</span>

<span class="fc" id="L583">        return new CNumber(re, im);</span>
    }


    /**
     * Computes the natural logarithm of a double. For non-negative values this function is equivalent to {@link Math#log}.
     * If the number is negative, then it is passed on as a complex value to {@link CNumber#ln(CNumber)}.
     * @param num Input to the complex natural logarithm function.
     * @return The principle value of the complex natural logarithm for the given input.
     */
    public static CNumber ln(double num) {
        CNumber result;

<span class="fc bfc" id="L596" title="All 2 branches covered.">        if(num&lt;0) {</span>
<span class="fc" id="L597">            result = CNumber.ln(new CNumber(num));</span>
        } else {
<span class="fc" id="L599">            result = new CNumber(Math.log(num));</span>
        }

<span class="fc" id="L602">        return result;</span>
    }


    /**
     * Computes the complex natural logarithm of a complex number. This function is the analytic continuation of
     * the natural logarithm, that is the log base {@link Math#E e}.
     * @param num Input to the complex natural logarithm function.
     * @return The principle value of the complex natural logarithm for the given input.
     */
    public static CNumber ln(CNumber num) {
        CNumber result;

<span class="fc bfc" id="L615" title="All 4 branches covered.">        if(num.isReal() &amp;&amp; num.re &gt;=0) {</span>
<span class="fc" id="L616">            result = new CNumber(Math.log(num.re));</span>

        } else {
<span class="fc" id="L619">            double re = Math.log(Math.sqrt(num.re*num.re + num.im*num.im));</span>
<span class="fc" id="L620">            double im = Math.atan2(num.im, num.re);</span>

<span class="fc" id="L622">            result = new CNumber(re, im);</span>
        }

<span class="fc" id="L625">        return result;</span>
    }


    /**
     * Computes the complex logarithm base 10 of a complex number. Please note, this is &lt;b&gt;NOT&lt;/b&gt; the natural logarithm.
     * If the complex natural logarithm is desired see {@link #ln(double)}. To specify a base, see {@link #log(double, CNumber)}
     * or {@link #log(CNumber, CNumber)}. If the argument is non-negative, then this function is equivalent to {@link Math#log(double)}.
     * @param num Input to the complex logarithm base 10 function.
     * @return The principle value of the complex logarithm base 10 for the given input.
     */
    public static CNumber log(double num) {
        CNumber result;

<span class="fc bfc" id="L639" title="All 2 branches covered.">        if(num &lt;= 0) {</span>
<span class="fc" id="L640">            result = CNumber.log(new CNumber(num));</span>
        } else {
<span class="fc" id="L642">            result = new CNumber(Math.log10(num));</span>
        }

<span class="fc" id="L645">        return result;</span>
    }


    /**
     * Computes the complex logarithm base 10 of a complex number. Please note, this is &lt;b&gt;NOT&lt;/b&gt; the complex natural logarithm.
     * If the complex natural logarithm is desired see {@link #ln(CNumber)}. To specify a base, see {@link #log(double, CNumber)}
     * or {@link #log(CNumber, CNumber)}.
     * @param num Input to the complex logarithm base 10 function.
     * @return The principle value of the complex logarithm base 10 for the given input.
     */
    public static CNumber log(CNumber num) {
        CNumber result;

<span class="fc bfc" id="L659" title="All 4 branches covered.">        if(num.isReal() &amp;&amp; num.re &gt;=0) {</span>
<span class="fc" id="L660">            result = new CNumber(Math.log10(num.re));</span>
        } else {
            // Using the change of base formula
<span class="fc" id="L663">            CNumber numerator = ln(num);</span>
<span class="fc" id="L664">            CNumber denominator = new CNumber(Math.log(10));</span>

<span class="fc" id="L666">            result = numerator.div(denominator);</span>
        }

<span class="fc" id="L669">        return result;</span>
    }


    /**
     * Computes the complex logarithm, with specified base, of a complex number.
     * @param num Input to the complex logarithm function with specified base.
     * @return The principle value of the complex logarithm, with specified base, for the given input.
     */
    public static CNumber log(double base, double num) {
<span class="fc" id="L679">        return CNumber.log(new CNumber(base), new CNumber(num));</span>
    }


    /**
     * Computes the complex logarithm, with specified base, of a complex number.
     * @param num Input to the complex logarithm function with specified base.
     * @return The principle value of the complex logarithm, with specified base, for the given input.
     */
    public static CNumber log(double base, CNumber num) {
<span class="fc" id="L689">        return CNumber.log(new CNumber(base), num);</span>
    }


    /**
     * Computes the complex logarithm, with specified base, of a complex number.
     * @param num Input to the complex logarithm function with specified base.
     * @return The principle value of the complex logarithm, with specified base, for the given input.
     */
    public static CNumber log(CNumber base, CNumber num) {
        // Using the change of base formula
<span class="fc" id="L700">        CNumber numerator = ln(num);</span>
<span class="fc" id="L701">        CNumber denominator = ln(base);</span>

<span class="fc" id="L703">        return numerator.div(denominator);</span>
    }


    /**
     * Computes the principle square root of a number. This method wraps {@link Math#sqrt(double)} and returns a {@link CNumber}.
     * @param num Input to square root.
     * @return The principle square root of a.
     */
    public static CNumber sqrt(double num) {
        CNumber result;

<span class="fc bfc" id="L715" title="All 2 branches covered.">        if(num &gt;=0) {</span>
<span class="fc" id="L716">            result = new CNumber(Math.sqrt(num));</span>
        } else {
<span class="fc" id="L718">            result = new CNumber(0, Math.sqrt(-num));</span>
        }

<span class="fc" id="L721">        return result;</span>
    }


    /**
     * Computes the principle square root of a number.
     * @param num Input to square root.
     * @return The principle square root of a. That is, the square root of a with positive real part.
     */
    public static CNumber sqrt(CNumber num) {
        CNumber result;

<span class="fc bfc" id="L733" title="All 4 branches covered.">        if(num.isReal() &amp;&amp; num.re&gt;=0) {</span>
<span class="fc" id="L734">            result = new CNumber(Math.sqrt(num.re));</span>

<span class="pc bpc" id="L736" title="1 of 4 branches missed.">        } else if(num.isReal() &amp;&amp; num.re&lt;0) {</span>
<span class="fc" id="L737">            result = new CNumber(0, Math.sqrt(-num.re));</span>

        } else {
<span class="fc" id="L740">            double mag = num.magAsDouble();</span>
<span class="fc" id="L741">            double factor = num.im / Math.abs(num.im);</span>

<span class="fc" id="L743">            double re = Math.sqrt((mag + num.re)/2);</span>
<span class="fc" id="L744">            double im = factor*Math.sqrt((mag - num.re)/2);</span>

<span class="fc" id="L746">            result = new CNumber(re, im);</span>
        }

<span class="fc" id="L749">        return result;</span>
    }


    /**
     * The complex signum function. Please note, if the value passed to this method is zero, the function will
     * return zero.
     *
     * @param value Value to evaluate the signum function at.
     * @return If the number is zero then this function returns zero. Otherwise, returns the number divided by its magnitude.
     */
    public static CNumber sgn(CNumber value) {
        CNumber result;

<span class="fc bfc" id="L763" title="All 2 branches covered.">        if(value.equals(CNumber.ZERO)) {</span>
<span class="fc" id="L764">            return CNumber.ZERO;</span>

<span class="fc bfc" id="L766" title="All 2 branches covered.">        } else if(value.im == 0) {</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">            if(value.re &gt; 0) {</span>
<span class="fc" id="L768">                result = new CNumber(1);</span>
            } else {
<span class="fc" id="L770">                result = new CNumber(-1);</span>
            }
        } else {
<span class="fc" id="L773">            result = value.div(value.magAsDouble());</span>
        }

<span class="fc" id="L776">        return result;</span>
    }


    /**
     * Converts a complex number to an equivalent polar from.
     * @return An array of length 2 containing in order, the radius and angle (in radians) if the complex number.
     */
    public double[] toPolar() {
<span class="fc" id="L785">        double[] polar = new double[2];</span>

        // Compute the magnitude and angle of the complex number.
<span class="fc" id="L788">        polar[0] = this.magAsDouble();</span>
<span class="fc" id="L789">        polar[1] = Math.atan2(this.im, this.re);</span>

<span class="fc" id="L791">        return polar;</span>
    }


    /**
     * Converts a complex number expressed in polar from to the rectangular form.
     * @param r Radius of complex number.
     * @param theta Angle of the complex number in radians.
     * @return An equivalent complex number in rectangular form.
     */
    public static CNumber fromPolar(double r, double theta) {
<span class="fc" id="L802">        double re = r*Math.cos(theta);</span>
<span class="fc" id="L803">        double im = r*Math.sin(theta);</span>

<span class="fc" id="L805">        return new CNumber(re, im);</span>
    }


    /**
     * Computes the 2 argument arc-tangent function for a complex number. That is, for a complex number a+bi, atan2(b, a)
     * is computed. This method wraps {@link Math#atan2(double, double)}. &lt;br&gt;
     * To get the result as an {@link CNumber} see {@link CNumber#atan2AsCNumber(CNumber)}.
     * @param num The input to the atan2 function.
     * @return The output of the atan2 function given the specified input. If the complex number is zero, then {@link Double#NaN}
     * is returned.
     */
    public static double atan2(CNumber num) {
<span class="nc" id="L818">        return Math.atan2(num.im, num.re);</span>
    }


    /**
     * Computes the complex argument function for a complex number.
     * is computed. This method is equivalent to {@link CNumber#atan2(CNumber)}. &lt;br&gt;
     * To get the result as an {@link CNumber} see {@link CNumber#argAsCNumber(CNumber)}.
     * @param num The input to the atan2 function.
     * @return The output of the atan2 function given the specified input. If the complex number is zero, then {@link Double#NaN}
     * is returned.
     */
    public static double arg(CNumber num) {
<span class="nc" id="L831">        return atan2(num);</span>
    }


    /**
     * Computes the complex argument function for a complex number.
     * is computed. This method wraps is equivalent to {@link CNumber#atan2AsCNumber(CNumber)} (CNumber)}. &lt;br&gt;
     * To get the result as an double see {@link CNumber#argAsCNumber(CNumber)}.
     * @param num The input to the atan2 function.
     * @return The output of the atan2 function given the specified input. If the complex number is zero, then {@link Double#NaN}
     * is returned.
     */
    public static CNumber argAsCNumber(CNumber num) {
<span class="nc" id="L844">        return atan2AsCNumber(num);</span>
    }


    /**
     * Computes the 2 argument arc-tangent function for a complex number. That is, for a complex number a+bi, atan2(b, a)
     * is computed. This method wraps {@link Math#atan2(double, double)}. &lt;br&gt;
     * To get the result as a double see {@link CNumber#atan2(CNumber)}.
     * @param num The input to the atan2 function.
     * @return The output of the atan2 function given the specified input. If the complex number is zero, then {@link Double#NaN}
     * is returned.
     */
    public static CNumber atan2AsCNumber(CNumber num) {
<span class="nc" id="L857">        return new CNumber(Math.atan2(num.im, num.re));</span>
    }


    /**
     * Computes the trigonometric sine of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#sin(double)} and returns a {@link CNumber}.
     * @param num Input angle in radians.
     * @return The trigonometric sine function evaluated at the specified value.
     */
    public static CNumber sin(double num) {
<span class="fc" id="L868">        return new CNumber(Math.sin(num));</span>
    }


    /**
     * Computes the trigonometric sine of a complex value.
     * @param num Complex valued input to the sine function. If num is real, then this is an angle in radians.
     * @return The trigonometric sine function evaluated at the specified value.
     */
    public static CNumber sin(CNumber num) {
<span class="fc" id="L878">        double re = Math.sin(num.re)*Math.cosh(num.im);</span>
<span class="fc" id="L879">        double im = Math.cos(num.re)*Math.sinh(num.im);</span>

<span class="fc" id="L881">        return new CNumber(re, im);</span>
    }


    /**
     * Computes the inverse sine of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#asin(double)} and returns {@link CNumber}.
     * @param num Input to the inverse sine function.
     * @return The inverse sine of the input value. That is, the angle whose sine value is num.
     */
    public static CNumber asin(double num) {
<span class="nc" id="L892">        return new CNumber(Math.asin(num));</span>
    }


    /**
     * Computes the inverse sine of a complex value. &lt;br&gt;
     * @param num Input to the inverse sine function.
     * @return The inverse sine of the input value.
     */
    public static CNumber asin(CNumber num) {
<span class="nc" id="L902">        CNumber diff = ONE.sub(num.mult(num));</span>
<span class="nc" id="L903">        CNumber denominator = CNumber.sqrt(diff);</span>

<span class="nc" id="L905">        return atan(num.div(denominator));</span>
    }


    /**
     * Computes the hyperbolic sine of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#sinh(double)} and returns a {@link CNumber}.
     * @param num Input to the hyperbolic sine function.
     * @return The hyperbolic sine of the input value.
     */
    public static CNumber sinh(double num) {
<span class="nc" id="L916">        return new CNumber(Math.sinh(num));</span>
    }


    /**
     * Computes the hyperbolic sine of a complex value.
     * @param num Input to the hyperbolic sine function.
     * @return The hyperbolic sine of the input value.
     */
    public static CNumber sinh(CNumber num) {
<span class="nc" id="L926">        CNumber numerator = exp(num).add(exp(num.addInv()));</span>
<span class="nc" id="L927">        CNumber denominator = new CNumber(2);</span>

<span class="nc" id="L929">        return numerator.div(denominator);</span>
    }


    /**
     * Computes the trigonometric cosine of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#cos(double)} and returns a {@link CNumber}.
     * @param num Input angle in radians.
     * @return The trigonometric cosine function evaluated at the specified value.
     */
    public static CNumber cos(double num) {
<span class="fc" id="L940">        return new CNumber(Math.cos(num));</span>
    }


    /**
     * Computes the trigonometric cosine value of a complex value.
     * @param num Complex valued input to the cosine function. If num is real, then this is an angle in radians.
     * @return The trigonometric cosine function evaluated at the specified value.
     */
    public static CNumber cos(CNumber num) {
<span class="fc" id="L950">        double re = Math.cos(num.re)*Math.cosh(num.im);</span>
<span class="fc" id="L951">        double im = Math.sin(num.re)*Math.sinh(num.im);</span>

<span class="fc" id="L953">        return new CNumber(re, im);</span>
    }


    /**
     * Computes the inverse cosine of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#acos(double)} and returns {@link CNumber}.
     * @param num Input to the inverse cosine function.
     * @return The inverse cosine of the input value. That is, the angle whose cosine value is num.
     */
    public static CNumber acos(double num) {
<span class="nc" id="L964">        return new CNumber(Math.acos(num));</span>
    }


    /**
     * Computes the inverse cosine of a complex value. &lt;br&gt;
     * @param num Input to the inverse cosine function.
     * @return The inverse cosine of the input value.
     */
    public static CNumber acos(CNumber num) {
<span class="nc" id="L974">        CNumber term = new CNumber(Math.PI/2);</span>

<span class="nc" id="L976">        return term.sub(asin(num));</span>
    }


    /**
     * Computes the hyperbolic cosine of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#cosh(double)} and returns a {@link CNumber}.
     * @param num Input to the hyperbolic cosine function.
     * @return The hyperbolic cosine of the input value.
     */
    public static CNumber cosh(double num) {
<span class="nc" id="L987">        return new CNumber(Math.cosh(num));</span>
    }


    /**
     * Computes the hyperbolic cosine of a complex value.
     * @param num Input to the hyperbolic cosine function.
     * @return The hyperbolic cosine of the input value.
     */
    public static CNumber cosh(CNumber num) {
<span class="nc" id="L997">        CNumber numerator = exp(num).sub(exp(num.addInv()));</span>
<span class="nc" id="L998">        CNumber denominator = new CNumber(2);</span>

<span class="nc" id="L1000">        return numerator.div(denominator);</span>
    }


    /**
     * Computes the trigonometric tangent of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#tan(double)} and returns a {@link CNumber}.
     * @param num Input angle in radians.
     * @return The trigonometric tangent function evaluated at the specified value.
     */
    public static CNumber tan(double num) {
<span class="fc" id="L1011">        return new CNumber(Math.tan(num));</span>
    }


    /**
     * Computes the trigonometric tangent value of a complex value.
     * @param num Complex valued input to the tangent function. If num is real, then this is an angle in radians.
     * @return The trigonometric tangent function evaluated at the specified value.
     */
    public static CNumber tan(CNumber num) {
<span class="fc" id="L1021">        CNumber numerator = new CNumber(Math.tan(num.re),</span>
<span class="fc" id="L1022">                Math.tanh(num.im));</span>
<span class="fc" id="L1023">        CNumber denominator = new CNumber(1,</span>
<span class="fc" id="L1024">                -Math.tan(num.re)*Math.tanh(num.im));</span>

<span class="fc" id="L1026">        return numerator.div(denominator);</span>
    }


    /**
     * Computes the inverse tangent of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#atan(double)} and returns {@link CNumber}.
     * @param num Input to the inverse tangent function.
     * @return The inverse tangent of the input value. That is, the angle whose tangent value is num.
     */
    public static CNumber atan(double num) {
<span class="nc" id="L1037">        return new CNumber(Math.atan(num));</span>
    }


    /**
     * Computes the inverse tangent of a complex value. &lt;br&gt;
     * @param num Input to the inverse tangent function.
     * @return The inverse tangent of the input value.
     */
    public static CNumber atan(CNumber num) {
<span class="nc" id="L1047">        CNumber factor = TWO.multInv();</span>
<span class="nc" id="L1048">        CNumber numerator = IMAGINARY_UNIT.sub(num);</span>
<span class="nc" id="L1049">        CNumber denominator = IMAGINARY_UNIT.add(num);</span>
<span class="nc" id="L1050">        CNumber log = CNumber.ln(numerator.div(denominator));</span>

<span class="nc" id="L1052">        return factor.mult(log);</span>
    }


    /**
     * Computes the hyperbolic tangent of a value. &lt;br&gt;
     * Note, this method wraps {@link Math#tanh(double)} and returns a {@link CNumber}.
     * @param num Input to the hyperbolic tangent function.
     * @return The hyperbolic tangent of the input value.
     */
    public static CNumber tanh(double num) {
<span class="nc" id="L1063">        return new CNumber(Math.tanh(num));</span>
    }


    /**
     * Computes the hyperbolic tangent of a complex value.
     * @param num Input to the hyperbolic tangent function.
     * @return The hyperbolic tangent of the input value.
     */
    public static CNumber tanh(CNumber num) {
<span class="nc" id="L1073">        CNumber exp = exp(TWO.mult(num));</span>
<span class="nc" id="L1074">        CNumber numerator = exp.sub(ONE);</span>
<span class="nc" id="L1075">        CNumber denominator = exp.add(ONE);</span>

<span class="nc" id="L1077">        return numerator.div(denominator);</span>
    }


    /**
     * Checks if this complex number has zero imaginary part.
     * @return True if this complex number has zero imaginary part. False otherwise.
     */
    public boolean isReal() {
<span class="fc bfc" id="L1086" title="All 2 branches covered.">        return this.im == 0;</span>
    }


    /**
     * Checks if this complex number has zero real part.
     * @return True if this complex number has zero real part. False otherwise.
     */
    public boolean isImaginary() {
<span class="fc bfc" id="L1095" title="All 2 branches covered.">        return this.re == 0;</span>
    }


    /**
     * Checks if this complex number has non-zero imaginary part.
     * @return True if this complex number has non-zero imaginary part. False otherwise.
     */
    public boolean isComplex() {
<span class="fc bfc" id="L1104" title="All 2 branches covered.">        return this.im != 0;</span>
    }


    /**
     * Rounds both components of a complex number to the nearest respective integer.
     * @param n The complex number to round.
     * @return A complex number with integer real and imaginary components closest to the real and imaginary
     * components of the parameter n
     * @throws NumberFormatException If n is {@link Double#NaN}, {@link Double#POSITIVE_INFINITY} or
     * {@link Double#NEGATIVE_INFINITY}
     */
    public static CNumber round(CNumber n) {
<span class="fc" id="L1117">        return round(n, 0);</span>
    }


    /**
     * Rounds number to specified number of decimal places. If the number is complex,
     * both the real and imaginary parts will be rounded.
     *
     * @param n Number to round.
     * @param decimals Number of decimals to round to.
     * @return The number &lt;code&gt;n&lt;/code&gt; rounded to the specified
     * 		number of decimals.
     * @throws IllegalArgumentException If decimals is less than zero.
     * @throws NumberFormatException If n is {@link Double#NaN}, {@link Double#POSITIVE_INFINITY} or
     * {@link Double#NEGATIVE_INFINITY}
     */
    public static CNumber round(CNumber n, int decimals) {
<span class="fc bfc" id="L1134" title="All 2 branches covered.">        if (decimals &lt; 0) {</span>
<span class="fc" id="L1135">            throw new IllegalArgumentException(ErrorMessages.negValueErr(decimals));</span>
        }

<span class="fc" id="L1138">        double real = BigDecimal.valueOf(n.re).setScale(decimals, RoundingMode.HALF_UP).doubleValue();</span>
<span class="fc" id="L1139">        double imaginary = BigDecimal.valueOf(n.im).setScale(decimals, RoundingMode.HALF_UP).doubleValue();</span>

<span class="fc" id="L1141">        return new CNumber(real, imaginary);</span>
    }


    /**
     * Checks if a number is near zero in magnitude.
     *
     * @param tol - tolerance of how close to zero is
     * 		considered &quot;near&quot;.
     * @return Returns true if magnitude of number is less than or equal to
     * 		&lt;code&gt;tol&lt;/code&gt;. Otherwise, returns false.
     * @throws IllegalArgumentException If tol is less than 0.
     */
    public static boolean nearZero(CNumber n, double tol) {
<span class="fc bfc" id="L1155" title="All 2 branches covered.">        if (tol &lt; 0) {</span>
<span class="fc" id="L1156">            throw new IllegalArgumentException(ErrorMessages.negValueErr(tol));</span>
        }

<span class="fc bfc" id="L1159" title="All 2 branches covered.">        return n.magAsDouble() &lt;= tol;</span>
    }


    /**
     * Compares the size of two complex numbers (magnitudes).
     *
     * @param b Number to compare to this number.
     * @return
     * - If the magnitude of this number is equal to that of &lt;code&gt;b&lt;/code&gt;, then this method will return 0. &lt;br&gt;
     * - If the magnitude of this number is less than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a negative number. &lt;br&gt;
     * - If the magnitude of this number is greater than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a positive number.
     */
    public int compareTo(CNumber b) {
<span class="fc bfc" id="L1173" title="All 2 branches covered.">        if(this.magAsDouble() == b.magAsDouble()) {return 0;}</span>
<span class="fc bfc" id="L1174" title="All 2 branches covered.">        else if(this.magAsDouble() &lt; b.magAsDouble()) {return -1;}</span>
<span class="fc" id="L1175">        else {return 1;}</span>
    }


    /**
     * Compares the real value of two numbers.
     *
     * @param b Number to compare to this number.
     * @return
     * - If the real value of this number is equal to that of &lt;code&gt;b&lt;/code&gt;, then this method will return 0. &lt;br&gt;
     * - If the real value of this number is less than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a negative number. &lt;br&gt;
     * - If the real value of this number is greater than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a positive number.
     */
    public int compareToReal(CNumber b) {
<span class="fc" id="L1189">        return compareToReal(b.re);</span>
    }


    /**
     * Compares the real value of two numbers. This method wraps {@link Double#compareTo(Double)} which is computed
     * with the real component of this complex number.
     *
     * @param b Number to compare to this number.
     * @return
     * - If the real value of this number is equal to that of &lt;code&gt;b&lt;/code&gt;, then this method will return 0. &lt;br&gt;
     * - If the real value of this number is less than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a negative number. &lt;br&gt;
     * - If the real value of this number is greater than that of &lt;code&gt;b&lt;/code&gt;, then this method will return a positive number.
     */
    public int compareToReal(double b) {
<span class="fc" id="L1204">        return Double.valueOf(this.re).compareTo(b);</span>
    }


    /**
     * Computes the minimum magnitude from an array of complex numbers.
     * @param values Array of values to compute the minimum magnitude from.
     * @return The minimum magnitude from the values array. If the array has zero length, then -1 is returned.
     */
    public static CNumber min(CNumber... values) {
<span class="fc" id="L1214">        double min = -1;</span>
        double currMag;

<span class="fc bfc" id="L1217" title="All 2 branches covered.">        if(values.length &gt; 0) {</span>
<span class="fc" id="L1218">            min = values[0].magAsDouble();</span>
        }

<span class="fc bfc" id="L1221" title="All 2 branches covered.">        for(CNumber value : values) {</span>
<span class="fc" id="L1222">            currMag = value.magAsDouble();</span>
<span class="fc bfc" id="L1223" title="All 2 branches covered.">            if(currMag &lt; min) {</span>
<span class="fc" id="L1224">                min = currMag;</span>
            }
        }

<span class="fc" id="L1228">        return new CNumber(min);</span>
    }


    /**
     * Computes the minimum real component from an array of complex numbers. All imaginary components are ignored.
     * @param values Array of values to compute the minimum real component from.
     * @return The minimum magnitude from the values array. If the array has zero length, {@link Double#NaN} is
     * returned.
     */
    public static CNumber minReal(CNumber... values) {
<span class="fc" id="L1239">        double min = Double.MAX_VALUE;</span>
        double currMin;

<span class="fc bfc" id="L1242" title="All 2 branches covered.">        if(values.length == 0) {</span>
<span class="fc" id="L1243">            min = Double.NaN;</span>
        }

<span class="fc bfc" id="L1246" title="All 2 branches covered.">        for(CNumber value : values) {</span>
<span class="fc" id="L1247">            currMin = value.re;</span>
<span class="fc bfc" id="L1248" title="All 2 branches covered.">            if(currMin &lt; min) {</span>
<span class="fc" id="L1249">                min = currMin;</span>
            }
        }

<span class="fc" id="L1253">        return new CNumber(min);</span>
    }


    /**
     * Computes the maximum magnitude from an array of complex numbers.
     * @param values Array of values to compute the maximum magnitude from.
     * @return The minimum magnitude from the values array. If the array has zero length, then -1 is returned.
     */
    public static CNumber max(CNumber... values) {
<span class="fc" id="L1263">        double max = -1;</span>
        double currMag;

<span class="fc bfc" id="L1266" title="All 2 branches covered.">        if(values.length &gt; 0) {</span>
<span class="fc" id="L1267">            max = values[0].magAsDouble();</span>
        }

<span class="fc bfc" id="L1270" title="All 2 branches covered.">        for(CNumber value : values) {</span>
<span class="fc" id="L1271">            currMag = value.magAsDouble();</span>
<span class="fc bfc" id="L1272" title="All 2 branches covered.">            if(currMag &gt; max) {</span>
<span class="fc" id="L1273">                max = currMag;</span>
            }
        }

<span class="fc" id="L1277">        return new CNumber(max);</span>
    }


    /**
     * Computes the minimum real component from an array of complex numbers. All imaginary components are ignored.
     * @param values Array of values to compute the minimum real component from.
     * @return The minimum magnitude from the values array. If the array has zero length, {@link Double#NaN} is
     * returned.
     */
    public static CNumber maxReal(CNumber... values) {
<span class="fc" id="L1288">        double max = Double.MIN_NORMAL;</span>
        double currMax;

<span class="fc bfc" id="L1291" title="All 2 branches covered.">        if(values.length == 0) {</span>
<span class="fc" id="L1292">            max = Double.NaN;</span>
        }

<span class="fc bfc" id="L1295" title="All 2 branches covered.">        for(CNumber value : values) {</span>
<span class="fc" id="L1296">            currMax = value.re;</span>
<span class="fc bfc" id="L1297" title="All 2 branches covered.">            if(currMax &gt; max) {</span>
<span class="fc" id="L1298">                max = currMax;</span>
            }
        }

<span class="fc" id="L1302">        return new CNumber(max);</span>
    }


    /**
     * Computes the index of the minimum magnitude from an array of complex numbers.
     * @param values Array of values to compute the index of the minimum magnitude from.
     * @return The index of the minimum magnitude from the values array. If the array has zero length, then -1 is returned.
     */
    public static int argMin(CNumber... values) {
<span class="fc" id="L1312">        double min = -1;</span>
        double currMag;
<span class="fc" id="L1314">        int arg = -1;</span>

<span class="fc bfc" id="L1316" title="All 2 branches covered.">        if(values.length &gt; 0) {</span>
<span class="fc" id="L1317">            min = values[0].magAsDouble();</span>
        }

<span class="fc bfc" id="L1320" title="All 2 branches covered.">        for(int i=0; i&lt;values.length; i++) {</span>
<span class="fc" id="L1321">            currMag = values[i].magAsDouble();</span>
<span class="fc bfc" id="L1322" title="All 2 branches covered.">            if(currMag &lt; min) {</span>
<span class="fc" id="L1323">                min = currMag;</span>
<span class="fc" id="L1324">                arg = i;</span>
            }
        }

<span class="fc" id="L1328">        return arg;</span>
    }


    /**
     * Computes the index of the minimum real component from an array of complex numbers. All imaginary components are ignored.
     * @param values Array of values to compute the index of the minimum real component from.
     * @return The index of the minimum magnitude from the values array. If the array has zero length, -1 is returned.
     */
    public static int argMinReal(CNumber... values) {
<span class="fc" id="L1338">        double min = Double.MAX_VALUE;</span>
        double currMin;
<span class="fc" id="L1340">        int arg = -1;</span>

<span class="fc bfc" id="L1342" title="All 2 branches covered.">        if(values.length == 0) {</span>
<span class="fc" id="L1343">            min = Double.NaN;</span>
        }

<span class="fc bfc" id="L1346" title="All 2 branches covered.">        for(int i=0; i&lt;values.length; i++) {</span>
<span class="fc" id="L1347">            currMin = values[i].re;</span>
<span class="pc bpc" id="L1348" title="1 of 2 branches missed.">            if(currMin &lt; min) {</span>
<span class="fc" id="L1349">                min = currMin;</span>
<span class="fc" id="L1350">                arg = i;</span>
            }
        }

<span class="fc" id="L1354">        return arg;</span>
    }


    /**
     * Computes the index of the maximum magnitude from an array of complex numbers.
     * @param values Array of values to compute the index of the maximum magnitude from.
     * @return The index of the minimum magnitude from the values array. If the array has zero length, then -1 is returned.
     */
    public static int argMax(CNumber... values) {
<span class="fc" id="L1364">        double max = -1;</span>
        double currMag;
<span class="fc" id="L1366">        int arg = -1;</span>

<span class="fc bfc" id="L1368" title="All 2 branches covered.">        if(values.length &gt; 0) {</span>
<span class="fc" id="L1369">            max = values[0].magAsDouble();</span>
        }

<span class="fc bfc" id="L1372" title="All 2 branches covered.">        for(int i=0; i&lt;values.length; i++) {</span>
<span class="fc" id="L1373">            currMag = values[i].magAsDouble();</span>
<span class="fc bfc" id="L1374" title="All 2 branches covered.">            if(currMag &gt; max) {</span>
<span class="fc" id="L1375">                max = currMag;</span>
<span class="fc" id="L1376">                arg = i;</span>
            }
        }

<span class="fc" id="L1380">        return arg;</span>
    }


    /**
     * Computes the index of the minimum real component from an array of complex numbers. All imaginary components are ignored.
     * @param values Array of values to compute the index of the minimum real component from.
     * @return The index of the minimum magnitude from the values array. If the array has zero length, -1 is
     * returned.
     */
    public static int argMaxReal(CNumber... values) {
<span class="fc" id="L1391">        double max = Double.MIN_NORMAL;</span>
        double currMax;
<span class="fc" id="L1393">        int arg = -1;</span>

<span class="fc bfc" id="L1395" title="All 2 branches covered.">        if(values.length == 0) {</span>
<span class="fc" id="L1396">            max = Double.NaN;</span>
        }

<span class="fc bfc" id="L1399" title="All 2 branches covered.">        for(int i=0; i&lt;values.length; i++) {</span>
<span class="fc" id="L1400">            currMax = values[i].re;</span>
<span class="fc bfc" id="L1401" title="All 2 branches covered.">            if(currMax &gt; max) {</span>
<span class="fc" id="L1402">                max = currMax;</span>
            }
        }

<span class="fc" id="L1406">        return arg;</span>
    }


    /**
     * Checks if this complex number is a real valued integer.
     * @return True if the real component of this number is an integer and the complex component is zero. Otherwise, returns false.
     */
    public boolean isInt() {
<span class="pc bpc" id="L1415" title="1 of 4 branches missed.">        boolean result = !(isInfinite() || isNaN());</span>
<span class="fc bfc" id="L1416" title="All 6 branches covered.">        return Math.rint(re)==re &amp;&amp; im==0 &amp;&amp; result;</span>
    }


    /**
     * Checks if this complex number is a real valued double.
     * @return True if the complex component is zero. Otherwise, returns false.
     */
    public boolean isDouble() {
<span class="fc bfc" id="L1425" title="All 2 branches covered.">        return im==0;</span>
    }


    /**
     * Checks if either component of this complex number is NaN.
     * @return True if either component is NaN. Otherwise, returns false.
     */
    public boolean isNaN() {
<span class="fc bfc" id="L1434" title="All 4 branches covered.">        return Double.isNaN(re) || Double.isNaN(im);</span>
    }


    /**
     * Checks that both components of this complex number are finite valued.
     * @return True if both components are finite. Otherwise, returns false (including NaN).
     */
    public boolean isFinite() {
<span class="fc bfc" id="L1443" title="All 4 branches covered.">        return Double.isFinite(re) &amp;&amp; Double.isFinite(im);</span>
    }


    /**
     * Checks if either component of this complex number is infinitely large in absolute value.
     * @return True if either components are infinite. Otherwise, returns false.
     */
    public boolean isInfinite() {
<span class="fc bfc" id="L1452" title="All 4 branches covered.">        return Double.isInfinite(re) || Double.isInfinite(im);</span>
    }



    /**
     * Gets the real component of this complex number.
     * @return The real component of this complex number.
     */
    public double getReal() {
<span class="fc" id="L1462">        return re;</span>
    }


    /**
     * Gets the imaginary component of this complex number.
     * @return The imaginary component of this complex number.
     */
    public double getImaginary() {
<span class="fc" id="L1471">        return im;</span>
    }


    /**
     * Gets the length of the string representation of this complex number.
     * @param a Complex number.
     * @return The length of the string representation of the number.
     */
    public static int length(CNumber a) {
<span class="fc" id="L1481">        return a.toString().length();</span>
    }


    /**
     * Converts the complex number to a string representation.
     * @return A string representation of the complex number.
     */
    public String toString() {
<span class="fc" id="L1490">        String result = &quot;&quot;;</span>

<span class="fc" id="L1492">        double real = this.re, imaginary = this.im;</span>

<span class="fc bfc" id="L1494" title="All 2 branches covered.">        if (real != 0) {</span>
<span class="fc bfc" id="L1495" title="All 2 branches covered.">            if (real % 1 == 0) {</span>
<span class="fc" id="L1496">                result += (int) real;</span>
            } else {
<span class="fc" id="L1498">                result += real;</span>
            }
        }

<span class="fc bfc" id="L1502" title="All 2 branches covered.">        if (imaginary != 0) {</span>
<span class="fc bfc" id="L1503" title="All 4 branches covered.">            if (imaginary &lt; 0 &amp;&amp; real != 0) {</span>
<span class="fc" id="L1504">                result += &quot; - &quot;;</span>
<span class="fc" id="L1505">                imaginary = -imaginary;</span>
<span class="fc bfc" id="L1506" title="All 2 branches covered.">            } else if (real != 0) {</span>
<span class="fc" id="L1507">                result += &quot; + &quot;;</span>
            }

<span class="fc bfc" id="L1510" title="All 2 branches covered.">            if (imaginary % 1 == 0) {</span>
<span class="fc bfc" id="L1511" title="All 2 branches covered.">                if(imaginary != 1) {</span>
<span class="fc bfc" id="L1512" title="All 2 branches covered.">                    if(imaginary == -1) {</span>
<span class="fc" id="L1513">                        result += '-';</span>
                    } else {
<span class="fc" id="L1515">                        result += (int) imaginary;</span>
                    }
                }
            } else {
<span class="fc" id="L1519">                result += imaginary;</span>
            }

<span class="fc" id="L1522">            result += &quot;i&quot;;</span>
        }

<span class="fc bfc" id="L1525" title="All 4 branches covered.">        if (real == 0 &amp;&amp; imaginary == 0) {</span>
<span class="fc" id="L1526">            result = &quot;0&quot;;</span>
        }

<span class="fc" id="L1529">        return result;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>